<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bluepath</title>
    <!-- Import Materialize CSS and JS -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet">
    <link href="/static/style.css" rel="stylesheet"> <!-- Add reference to the new CSS file -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script>
        function deleteAuthorizedMac(mac, listItem) {
            $.ajax({
                url: '/authorized_macs',
                type: 'DELETE',
                contentType: 'application/json',
                data: JSON.stringify({ mac: mac }),
                success: function() {
                    listItem.remove();
                }
            });
        }

        function isValidMacAddress(mac) {
            const macRegex = /^([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})$/;
            return macRegex.test(mac);
        }

        function addAuthorizedMac(mac) {
            if (!isValidMacAddress(mac)) {
                alert("Invalid MAC address format. Please enter a valid MAC address.");
                return;
            }
            $.ajax({
                url: '/authorized_macs',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ mac: mac }),
                success: function() {
                    const listItem = $('<li>').text(mac);
                    const deleteButton = $('<button>').text('X').addClass('delete-button');
                    deleteButton.on('click', function() {
                        deleteAuthorizedMac(mac, listItem);
                    });
                    listItem.append(deleteButton);
                    $('#authorized-macs-list').append(listItem);
                    $('#authorized-mac-input').val('');
                }
            });
        }

        function deleteRestrictedZone(zone, listItem) {
            $.ajax({
                url: '/restrictedzones',
                type: 'DELETE',
                contentType: 'application/json',
                data: JSON.stringify({ restrictedzone: zone }),
                success: function() {
                    listItem.remove();
                    removeRestrictedZoneElement(zone.x, zone.y);
                }
            });
        }

        function addRestrictedZone(zone) {
            $.ajax({
                url: '/restrictedzones/toggle',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ x: zone.x, y: zone.y }),
                success: function(message) {
                    if (message === 'Restricted zone added') {
                        const listItem = $('<li>').text(`(${zone.x}, ${zone.y})`).attr('data-x', zone.x).attr('data-y', zone.y);
                        const deleteButton = $('<button>').text('X').addClass('delete-button');
                        deleteButton.on('click', function() {
                            deleteRestrictedZone(zone, listItem);
                        });
                        listItem.append(deleteButton);
                        $('#restrictedzones-list').append(listItem);
                        createRestrictedZoneElement(zone.x, zone.y);
                    } else {
                        removeRestrictedZoneElement(zone.x, zone.y);
                        removeRestrictedZoneListItem(zone.x, zone.y);
                    }
                }
            });
        }

        function createRestrictedZoneElement(x, y) {
            const restrictedzone = document.createElement("div");
            restrictedzone.classList.add("restrictedzone");
            restrictedzone.style.left = `${x}px`;
            restrictedzone.style.top = `${y}px`;
            restrictedzone.dataset.x = x;
            restrictedzone.dataset.y = y;
            document.querySelector(".gridmap").appendChild(restrictedzone);
        }

        function removeRestrictedZoneElement(x, y) {
            const restrictedzones = document.querySelectorAll(`.restrictedzone[data-x="${x}"][data-y="${y}"]`);
            restrictedzones.forEach(restrictedzone => restrictedzone.remove());
        }

        function removeRestrictedZoneListItem(x, y) {
            const listItem = $(`#restrictedzones-list li[data-x="${x}"][data-y="${y}"]`);
            if (listItem) {
                listItem.remove();
            }
        }

        function findDevicesInRestrictedZones() {
            const restrictedDevices = [];
            const devices = document.querySelectorAll('.device');
            const restrictedZones = document.querySelectorAll('.restrictedzone');

            devices.forEach(device => {
                const deviceRect = device.getBoundingClientRect();
                restrictedZones.forEach(zone => {
                    const zoneRect = zone.getBoundingClientRect();
                    if (
                        deviceRect.left < zoneRect.right &&
                        deviceRect.right > zoneRect.left &&
                        deviceRect.top < zoneRect.bottom &&
                        deviceRect.bottom > zoneRect.top
                    ) {
                        restrictedDevices.push(device.alt);
                    }
                });
            });

            return restrictedDevices;
        }

        function sendNotification(message) {
            if (Notification.permission === "granted") {
                new Notification(message);
            } else if (Notification.permission !== "denied") {
                Notification.requestPermission().then(permission => {
                    if (permission === "granted") {
                        new Notification(message);
                    }
                });
            }
        }

        const notifiedDevices = new Set();

        function updateRestrictedDevicesList(restrictedDevices) {
            const list = $('#unauthorized-devices-list');
            list.empty();
            restrictedDevices.forEach(device => {
                const listItem = $('<li>').text(device).css('color', 'red');
                list.append(listItem);
                const deviceElement = document.querySelector(`.device[alt="Device ${device}"]`);
                if (deviceElement) {
                    deviceElement.classList.add('unauthorized-device');
                }
                if (!notifiedDevices.has(device)) {
                    sendNotification(`Unauthorized device ${device} detected in restricted zone!`);
                    notifiedDevices.add(device);
                }
            });
            // Remove devices that are no longer in restricted zones from the notified set
            notifiedDevices.forEach(device => {
                if (!restrictedDevices.includes(device)) {
                    notifiedDevices.delete(device);
                }
            });
        }

        document.addEventListener("DOMContentLoaded", () => {
            const container = document.querySelector(".gridmap");
            let nodePositions = []; // Initialize nodePositions as an empty array
            const processedIPs = new Set();
            const socket = io();
            const deviceElements = new Map(); // Map to store device elements
            let isDrawing = false;
            let drawingEnabled = false;

            // Pan/zoom variables
            let scale = 1;
            let panX = 0;
            let panY = 0;
            let isPanning = false;
            let startX, startY;

            // In your DOMContentLoaded event, replace the panning initialization with:
            setupPanZoom(document.querySelector('.gridmap-container'));

            container.style.transform = `translate(${panX}px, ${panY}px)`;

            function createDraggableNode(ip, x, y) {
                const img = document.createElement("img");
                img.src = "/static/node.png";
                img.alt = `Node ${ip}`;
                img.classList.add("draggable");
                img.style.left = `${x * scale + panX}px`;
                img.style.top = `${y * scale + panY}px`;
                // ... rest of existing code ...

                // Disable default drag behavior
                img.addEventListener("dragstart", (e) => e.preventDefault());

                // Make image draggable
                img.addEventListener("mousedown", (e) => {
                    const boxRect = container.getBoundingClientRect();
                    const offsetX = e.clientX - img.getBoundingClientRect().left;
                    const offsetY = e.clientY - img.getBoundingClientRect().top;

                    const onMouseMove = (moveEvent) => {
                        let x = moveEvent.clientX - boxRect.left - offsetX;
                        let y = moveEvent.clientY - boxRect.top - offsetY;

                        img.style.left = `${x}px`;
                        img.style.top = `${y}px`;

                        // Update label position
                        label.style.left = `${x}px`;
                        label.style.top = `${y + 25}px`;
                    };

                    const onMouseUp = () => {
                        document.removeEventListener("mousemove", onMouseMove);
                        document.removeEventListener("mouseup", onMouseUp);

                        // Save the updated position
                        const x = parseInt(img.style.left);
                        const y = parseInt(img.style.top);

                        // Find the index of the node in the nodePositions array
                        const nodeIndex = nodePositions.findIndex(n => n.ip === ip);
                        if (nodeIndex !== -1) {
                            nodePositions[nodeIndex] = { ip, x, y };
                        } else {
                            nodePositions.push({ ip, x, y });
                        }

                        // Emit the node_moved event to the server
                        socket.emit('node_moved', { nodes: nodePositions });
                    };

                    document.addEventListener("mousemove", onMouseMove);
                    document.addEventListener("mouseup", onMouseUp);
                });

                // Create label element
                const label = document.createElement("div");
                label.textContent = ip;
                label.classList.add("node-label");
                label.style.left = img.style.left;
                label.style.top = `${parseInt(img.style.top) + 25}px`;

                // Append image and label to the container
                container.appendChild(img);
                container.appendChild(label);

                // Add node to nodePositions array
                nodePositions.push({ ip, x, y });
            }

            function createDevice(address, x, y, name = null) {
                const img = document.createElement("img");
                img.src = "/static/device.png";
                img.alt = `Device ${address}`;
                img.classList.add("device");
                img.style.left = `${x * scale + panX}px`;
                img.style.top = `${y * scale + panY}px`;
                img.style.position = "absolute"; // Ensure the image is positioned absolutely

                // Create label element
                const label = document.createElement("div");
                label.textContent = name || address; // Use name if available, otherwise use address
                label.classList.add("node-label");
                label.style.left = img.style.left;
                label.style.top = `${parseInt(img.style.top) + 25}px`;
                label.style.position = "absolute"; // Ensure the label is positioned absolutely

                // Append image and label to the container
                container.appendChild(img);
                container.appendChild(label);

                // Store the device elements in the map
                deviceElements.set(address, { img, label });
            }

            function updateNodes(nodes) {
                console.log("Updating nodes:", nodes);
                // Clear existing nodes
                container.innerHTML = '';
                nodePositions = []; // Reset nodePositions array

                nodes.forEach((node) => {
                    const { ip, x, y } = node;
                    processedIPs.add(ip);
                    createDraggableNode(ip, x, y);
                });
            }

            function updateDevices(devices) {
                console.log("Updating devices:", devices);
                if (!Array.isArray(devices)) {
                    console.error("Devices is not an array:", devices);
                    return;
                }
                devices.forEach((device) => {
                    const { address, x, y, name } = device;
                    if (deviceElements.has(address)) {
                        // Update existing device position
                        const { img, label } = deviceElements.get(address);
                        img.style.left = `${x}px`;
                        img.style.top = `${y}px`;
                        label.style.left = img.style.left;
                        label.style.top = `${parseInt(img.style.top) + 25}px`;
                        label.textContent = name || address; // Update label text
                    } else {
                        // Create new device
                        createDevice(address, x, y, name);
                    }
                });
                // Update device list in the device history tab
                const deviceList = document.getElementById('device-list');
                deviceList.innerHTML = '';
                devices.forEach(device => {
                    const listItem = document.createElement('li');
                    listItem.textContent = device.name || device.address;
                    listItem.dataset.address = device.address;
                    deviceList.appendChild(listItem);
                });
            }

            function snapToGrid(value) {
                return Math.floor(value / 25) * 25;
            }

            function handleClick(e) {
                if (!drawingEnabled) return;

                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Compute grid position with just panning
                const realX = mouseX - panX;
                const realY = mouseY - panY;

                // Snap to grid
                const x = snapToGrid(realX);
                const y = snapToGrid(realY);

                const zone = { x, y };
                console.log('Adding restricted zone at:', zone);
                addRestrictedZone(zone);
            }

            container.addEventListener("click", handleClick);

            // Initialize pan/zoom
            setupPanZoom(document.querySelector('.gridmap-container'));

            // Enhanced Pan/Zoom Handlers
            function setupPanZoom(mapContainer) {
                mapContainer.addEventListener('mousedown', (e) => {
                    if (e.button !== 0 || drawingEnabled) return;
                    isPanning = true;
                    startX = e.clientX - panX;
                    startY = e.clientY - panY;
                    mapContainer.style.cursor = 'grabbing';
                });

                mapContainer.addEventListener('mousemove', (e) => {
                    if (!isPanning) return;
                    
                    panX = e.clientX - startX;
                    panY = e.clientY - startY;
                    
                    const maxX = mapContainer.offsetWidth * (scale - 1);
                    const maxY = mapContainer.offsetHeight * (scale - 1);
                    
                    panX = Math.min(0, Math.max(-maxX, panX));
                    panY = Math.min(0, Math.max(-maxY, panY));

                    updateTransform();
                });

                mapContainer.addEventListener('mouseup', () => {
                    isPanning = false;
                    mapContainer.style.cursor = 'grab';
                });

                mapContainer.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomIntensity = 0.1;
                    const oldScale = scale;
                    const rect = mapContainer.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    scale *= 1 + (e.deltaY > 0 ? -zoomIntensity : zoomIntensity);
                    scale = Math.min(Math.max(1, scale), 5);

                    panX = (panX - mouseX) * (scale / oldScale) + mouseX;
                    panY = (panY - mouseY) * (scale / oldScale) + mouseY;

                    updateTransform();
                });

                function updateTransform() {
                    container.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                }
            }

            // Modified handleClick to account for pan/zoom
            function handleClick(e) {
                if (!drawingEnabled) return;

                const rect = container.getBoundingClientRect();
                const mouseX = (e.clientX - rect.left - panX) / scale;
                const mouseY = (e.clientY - rect.top - panY) / scale;

                const x = snapToGrid(mouseX);
                const y = snapToGrid(mouseY);

                const zone = { x, y };
                console.log('Adding restricted zone at:', zone);
                addRestrictedZone(zone);
            }

            // Fetch initial node positions from the server
            fetch('/get_nodespos')
                .then(response => response.json())
                .then(data => {
                    updateNodes(data.nodes);
                });

            // Fetch initial restricted zones from the server
            fetch('/restrictedzones')
                .then(response => response.json())
                .then(data => {
                    data.restrictedzones.forEach(zone => {
                        createRestrictedZoneElement(zone.x, zone.y);
                    });
                });

            // Listen for updates from the server
            socket.on('update_nodes', (data) => {
                updateNodes(data.nodes);
            });

            socket.on('update_logs', (data) => {
                // Update log table
                const logTableBody = document.querySelector('#log-table tbody');
                logTableBody.innerHTML = '';
                for (const [ip, logs] of Object.entries(data.log_data)) {
                    logs.forEach(log => {
                        const row = document.createElement('tr');
                        row.classList.add('log-row');
                        row.innerHTML = `
                            <td>${ip}</td>
                            <td>${log[0]}</td>
                            <td class="device-name">${log[1]}</td>
                            <td>${log[2]}</td>
                            <td>${log[3]}</td>
                            <td class="log-data" style="display:none">${log[4]}</td>
                        `;
                        logTableBody.appendChild(row);
                    });
                }
                // Ensure address_coordinates is an array
                const addressCoordinatesArray = Object.entries(data.address_coordinates).map(([address, coords]) => ({
                    address,
                    x: coords[0],
                    y: coords[1],
                    name: coords[2] // Get the name from address_coordinates
                }));
                // Update devices
                updateDevices(addressCoordinatesArray);
                updateRestrictedDevicesList(data.restricted_devices);
            });

            // Filter Bluetooth devices with names
            function filterBluetoothDevices(showBluetooth) {
                document.querySelectorAll(".log-row").forEach(row => {
                    const deviceName = row.querySelector(".device-name").textContent;
                    if (showBluetooth && !deviceName) {
                        row.style.display = "none";
                    } else {
                        row.style.display = "";
                    }
                });
                document.querySelectorAll(".device").forEach(device => {
                    const deviceName = device.alt.split(' ')[1];
                    if (showBluetooth && !deviceName) {
                        device.style.display = "none";
                    } else {
                        device.style.display = "";
                    }
                });
            }

            document.querySelectorAll("#showBluetooth").forEach(checkbox => {
                checkbox.addEventListener("change", (e) => {
                    const showBluetooth = e.target.checked;
                    filterBluetoothDevices(showBluetooth);
                });
            });

            // Tab functionality
            document.querySelectorAll(".tab a").forEach(tab => {
                tab.addEventListener("click", (e) => {
                    e.preventDefault();
                    const target = e.target.getAttribute("href").substring(1);
                    
                    // Don't clear history visualization when switching tabs
                    // Just clear when selecting a new device or date
                    
                    document.querySelectorAll(".tab-content").forEach(content => {
                        content.classList.add("hidden");
                    });
                    document.getElementById(target).classList.remove("hidden");
                });
            });

            // Show the grid map tab by default
            document.querySelector('.tabs a[href="#gridmap-tab"]').click();

            // Toggle selection mode for restricted zone
            $('#enable-drawing').click(function() {
                drawingEnabled = !drawingEnabled;
                $(this).toggleClass('active');
            });

            // Load authorized MAC addresses
            $.get('/authorized_macs', function(data) {
                data.authorized_macs.forEach(function(mac) {
                    const listItem = $('<li>').text(mac);
                    const deleteButton = $('<button>').text('X').addClass('delete-button');
                    deleteButton.on('click', function() {
                        deleteAuthorizedMac(mac, listItem);
                    });
                    listItem.append(deleteButton);
                    $('#authorized-macs-list').append(listItem);
                });
            });

            // Add authorized MAC address
            $('#add-authorized-mac-form').submit(function(event) {
                event.preventDefault();
                const mac = $('#authorized-mac-input').val();
                addAuthorizedMac(mac);
            });

            // Request notification permission on page load
            if (Notification.permission !== "granted") {
                Notification.requestPermission();
            }

            // Add event listener for history dates
            document.getElementById('history-list').addEventListener('click', (event) => {
                if (event.target.classList.contains('history-date')) {
                    document.querySelectorAll('.history-date').forEach(date => {
                        date.classList.remove('selected-date');
                    });
                    event.target.classList.add('selected-date');

                    // Clear previous history visualization
                    document.querySelectorAll('.history-dot, .grid-square').forEach(el => el.remove());

                    const address = event.target.dataset.address;
                    const date = event.target.textContent;
                    fetch(`/device_history/${address}`)
                        .then(response => response.json())
                        .then(data => {
                            const gridSquares = {}; // Object to store dots by grid square
                            const historyGrid = document.querySelector('#history-view');

                            data.history
                                .filter(entry => entry.date === date)
                                .forEach(entry => {
                                    const dot = document.createElement('div');
                                    dot.classList.add('history-dot');
                                    dot.style.left = `${entry.x}px`;
                                    dot.style.top = `${entry.y}px`;
                                    const time = new Date(`1970-01-01T${entry.time}Z`).toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit', hour12: true });
                                    dot.dataset.times = time; // Change from dataset.time to dataset.times to match tooltip code
                                    historyGrid.appendChild(dot);

                                    // Calculate grid square coordinates
                                    const gridX = Math.floor(entry.x / 25) * 25;
                                    const gridY = Math.floor(entry.y / 25) * 25;
                                    const gridKey = `${gridX},${gridY}`;

                                    if (!gridSquares[gridKey]) {
                                        gridSquares[gridKey] = [];
                                    }
                                    gridSquares[gridKey].push(time);
                                });

                            // Create grid squares
                            for (const [key, times] of Object.entries(gridSquares)) {
                                const [gridX, gridY] = key.split(',').map(Number);
                                const gridSquare = document.createElement('div');
                                gridSquare.classList.add('grid-square');
                                gridSquare.style.left = `${gridX}px`;
                                gridSquare.style.top = `${gridY}px`;
                                gridSquare.dataset.times = times.join('\n');
                                historyGrid.appendChild(gridSquare);
                            }
                        });
                }
            });

            // Add tooltip functionality
            const tooltip = document.createElement('div');
            tooltip.classList.add('tooltip');
            document.body.appendChild(tooltip);

            // Update these event listeners to target both gridmap and history-view
            document.querySelectorAll('#gridmap, #history-view').forEach(container => {
                container.addEventListener('mouseover', (event) => {
                    const target = event.target;
                    if (target.classList.contains('grid-square') || target.classList.contains('history-dot')) {
                        const tooltipText = target.dataset.times;
                        if (tooltipText) {
                            tooltip.textContent = tooltipText;
                            tooltip.style.display = 'block';
                            tooltip.style.left = `${event.pageX + 10}px`;
                            tooltip.style.top = `${event.pageY + 10}px`;
                        }
                    }
                });

                container.addEventListener('mousemove', (event) => {
                    if (tooltip.style.display === 'block') {
                        tooltip.style.left = `${event.pageX + 10}px`;
                        tooltip.style.top = `${event.pageY + 10}px`;
                    }
                });

                container.addEventListener('mouseout', (event) => {
                    const target = event.target;
                    if (target.classList.contains('grid-square') || target.classList.contains('history-dot')) {
                        tooltip.style.display = 'none';
                    }
                });
            });

            // Add event listener for device list items in the device history tab
            document.getElementById('device-list').addEventListener('click', (event) => {
                if (event.target.tagName === 'LI') {
                    // Highlight the selected device
                    document.querySelectorAll('#device-list li').forEach(device => {
                        device.classList.remove('selected-device-list-item');
                    });
                    event.target.classList.add('selected-device-list-item');

                    const address = event.target.dataset.address;
                    localStorage.setItem('selectedDevice', address); // Store selected device in local storage

                    fetch(`/device_history/${address}`)
                        .then(response => response.json())
                        .then(data => {
                            const historyList = document.getElementById('history-list');
                            historyList.innerHTML = '';
                            const dates = new Set(data.history.map(entry => entry.date));
                            dates.forEach(date => {
                                const li = document.createElement('li');
                                li.textContent = date;
                                li.classList.add('history-date');
                                li.dataset.address = address;
                                li.dataset.date = date;
                                historyList.appendChild(li);
                            });
                        });
                }
            });

            // Highlight the selected device on page load
            document.addEventListener('DOMContentLoaded', () => {
                const selectedDevice = localStorage.getItem('selectedDevice');
                if (selectedDevice) {
                    const deviceListItem = document.querySelector(`#device-list li[data-address="${selectedDevice}"]`);
                    if (deviceListItem) {
                        deviceListItem.classList.add('selected-device-list-item');
                    }
                }
            });
        }); // Close the main DOMContentLoaded event listener

        function generateHeatmap() {
            // Clear any existing heatmap visualization
            document.querySelectorAll('.heatmap-square').forEach(el => el.remove());
            const gridSquares = {};
            const currentTab = document.querySelector('.tab-content:not(.hidden)');
            const gridmap = currentTab.querySelector('.gridmap');

            fetch('/device_history.json')
                .then(response => {
                    if (!response.ok) throw new Error('Network response was not ok');
                    return response.json();
                })
                .then(deviceHistory => {
                    if (!deviceHistory) throw new Error('No data received');

                    // Process initial counts
                    Object.entries(deviceHistory).forEach(([address, dateEntries]) => {
                        Object.entries(dateEntries).forEach(([date, entries]) => {
                            entries.forEach(entry => {
                                const gridX = Math.floor(entry.x / 25) * 25;
                                const gridY = Math.floor(entry.y / 25) * 25;
                                const gridKey = `${gridX},${gridY}`;
                                gridSquares[gridKey] = (gridSquares[gridKey] || 0) + 1;
                            });
                        });
                    });

                    // Create spread effect
                    const spreadIntensity = (baseX, baseY, intensity) => {
                        const spread = [
                            [-1, -1], [0, -1], [1, -1],
                            [-1,  0],          [1,  0],
                            [-1,  1], [0,  1], [1,  1]
                        ];
                        
                        spread.forEach(([dx, dy]) => {
                            const newX = baseX + (dx * 25);
                            const newY = baseY + (dy * 25);
                            const spreadKey = `${newX},${newY}`;
                            const currentValue = gridSquares[spreadKey] || 0;
                            // Add fraction of center intensity to surrounding squares
                            gridSquares[spreadKey] = Math.max(currentValue, intensity * 0.3);
                        });
                    };

                    // Apply spread effect to each occupied square
                    Object.entries(gridSquares).forEach(([key, count]) => {
                        const [baseX, baseY] = key.split(',').map(Number);
                        spreadIntensity(baseX, baseY, count);
                    });

                    // Find the maximum count for normalization
                    const maxCount = Math.max(...Object.values(gridSquares), 1);

                    // Create heatmap squares with interpolated colors
                    Object.entries(gridSquares).forEach(([key, count]) => {
                        const [gridX, gridY] = key.split(',').map(Number);
                        const heatmapSquare = document.createElement('div');
                        heatmapSquare.classList.add('heatmap-square');
                        heatmapSquare.style.left = `${gridX}px`;
                        heatmapSquare.style.top = `${gridY}px`;
                        
                        const intensity = Math.pow(count / maxCount, 0.7); // Add exponential scaling
                        heatmapSquare.style.backgroundColor = `rgba(255, 0, 0, ${intensity})`;
                        heatmapSquare.dataset.count = Math.round(count);
                        heatmapSquare.title = `Visits: ${Math.round(count)}`;
                        gridmap.appendChild(heatmapSquare);
                    });
                })
                .catch(error => {
                    console.error('Error loading device history:', error);
                });
        }

        $(document).ready(function() {
            // Load restricted zones
            $.get('/restrictedzones', function(data) {
                data.restrictedzones.forEach(function(zone) {
                    const listItem = $('<li>').text(`(${zone.x}, ${zone.y})`).attr('data-x', zone.x).attr('data-y', zone.y);
                    const deleteButton = $('<button>').text('X').addClass('delete-button');
                    deleteButton.on('click', function() {
                        deleteRestrictedZone(zone, listItem);
                    });
                    listItem.append(deleteButton);
                    $('#restrictedzones-list').append(listItem);
                    createRestrictedZoneElement(zone.x, zone.y);
                });
            });

            // Enable drawing for restricted zone
            $('#add-restrictedzone-form').submit(function(event) {
                event.preventDefault();
                drawingEnabled = true;
                M.toast({html: 'Select area for restricted zone'});
            });

            // Toggle selection mode for restricted zone
            $('#enable-drawing').click(function() {
                drawingEnabled = !drawingEnabled;
                $(this).toggleClass('active');
            });

            // Add event listener for generate heatmap button
            $('#generateHeatmapButton').click(function() {
                generateHeatmap();
            });
        });

        document.addEventListener("DOMContentLoaded", () => {
            const gridmapContainer = document.querySelector('.gridmap-container');
            const historyViewContainer = document.querySelector('#history-view');
            const heatmapContainer = document.querySelector('#gridmap');

            // Initialize pan/zoom for all relevant containers
            setupPanZoom(gridmapContainer);
            setupPanZoom(historyViewContainer);
            setupPanZoom(heatmapContainer);

            function setupPanZoom(container) {
                let scale = 1;
                let panX = 0;
                let panY = 0;
                let isPanning = false;
                let startX, startY;

                container.addEventListener('mousedown', (e) => {
                    if (e.button !== 0) return; // Only handle left-click
                    isPanning = true;
                    startX = e.clientX - panX;
                    startY = e.clientY - panY;
                    container.style.cursor = 'grabbing';
                });

                container.addEventListener('mousemove', (e) => {
                    if (!isPanning) return;

                    panX = e.clientX - startX;
                    panY = e.clientY - startY;

                    const maxX = container.offsetWidth * (scale - 1);
                    const maxY = container.offsetHeight * (scale - 1);

                    panX = Math.min(0, Math.max(-maxX, panX));
                    panY = Math.min(0, Math.max(-maxY, panY));

                    updateTransform();
                });

                container.addEventListener('mouseup', () => {
                    isPanning = false;
                    container.style.cursor = 'grab';
                });

                container.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomIntensity = 0.1;
                    const oldScale = scale;
                    const rect = container.getBoundingClientRect();
                    const mouseX = e.clientX - rect.left;
                    const mouseY = e.clientY - rect.top;

                    scale *= 1 + (e.deltaY > 0 ? -zoomIntensity : zoomIntensity);
                    scale = Math.min(Math.max(1, scale), 5);

                    panX = (panX - mouseX) * (scale / oldScale) + mouseX;
                    panY = (panY - mouseY) * (scale / oldScale) + mouseY;

                    updateTransform();
                });

                function updateTransform() {
                    const grid = container.querySelector('.gridmap');
                    if (grid) {
                        grid.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                    }
                }
            }
        });
    </script>
    <script>
    document.addEventListener("DOMContentLoaded", () => {
        const gridmapContainer = document.querySelector('.gridmap-container');
        const historyViewContainer = document.querySelector('#history-view').parentElement; // Parent of history-view
        const heatmapContainer = document.querySelector('#heatmap-tab .gridmap-container'); // Heatmap container

        // Initialize pan/zoom for all relevant containers
        setupPanZoom(gridmapContainer);
        setupPanZoom(historyViewContainer);
        setupPanZoom(heatmapContainer);

        function setupPanZoom(container) {
            let scale = 1;
            let panX = 0;
            let panY = 0;
            let isPanning = false;
            let startX, startY;

            container.addEventListener('mousedown', (e) => {
                if (e.button !== 0) return; // Only handle left-click
                isPanning = true;
                startX = e.clientX - panX;
                startY = e.clientY - panY;
                container.style.cursor = 'grabbing';
            });

            container.addEventListener('mousemove', (e) => {
                if (!isPanning) return;

                panX = e.clientX - startX;
                panY = e.clientY - startY;

                const maxX = container.offsetWidth * (scale - 1);
                const maxY = container.offsetHeight * (scale - 1);

                panX = Math.min(0, Math.max(-maxX, panX));
                panY = Math.min(0, Math.max(-maxY, panY));

                updateTransform();
            });

            container.addEventListener('mouseup', () => {
                isPanning = false;
                container.style.cursor = 'grab';
            });

            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomIntensity = 0.1;
                const oldScale = scale;
                const rect = container.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                scale *= 1 + (e.deltaY > 0 ? -zoomIntensity : zoomIntensity);
                scale = Math.min(Math.max(1, scale), 5);

                panX = (panX - mouseX) * (scale / oldScale) + mouseX;
                panY = (panY - mouseY) * (scale / oldScale) + mouseY;

                updateTransform();
            });

            function updateTransform() {
                const grid = container.querySelector('.gridmap');
                if (grid) {
                    grid.style.transform = `translate(${panX}px, ${panY}px) scale(${scale})`;
                }
            }
        }
    });
</script>
</head>
<body>
    <div class="container">
        <h1 class="center-align accent-blue">Bluepath</h1>
        <div class="row">
            <div class="col s12">
                <ul class="tabs accent-blue-bg">
                    <li class="tab col s3"><a href="#gridmap-tab">Grid Map</a></li>
                    <li class="tab col s3"><a href="#logs-tab">Logs</a></li>
                    <li class="tab col s3"><a href="#device-history-tab">Device History</a></li>
                    <li class="tab col s3"><a href="#heatmap-tab">Heatmap</a></li>
                </ul>
            </div>
            <div id="gridmap-tab" class="col s12 tab-content hidden">
                <div class="row">
                    <div class="col s8">
                        <label>
                            <input type="checkbox" id="showBluetooth">
                            <span>Show only Bluetooth devices with a name</span>
                        </label>
                        <div class="gridmap-container">
                            <div id="gridmap" class="gridmap"></div>
                        </div>
                        <div class="legend">
                            <span>1 meter = 100px</span>
                        </div>
                    </div>
                    <div class="col s4 sidebar">
                        <h5 class="accent-blue">Authorized MAC Addresses</h5>
                        <form id="add-authorized-mac-form" style="display: flex; align-items: center;">
                            <input type="text" id="authorized-mac-input" placeholder="Enter MAC address" required style="flex: 1; margin-right: 10px;">
                            <button type="submit" class="add-button">+</button>
                        </form>
                        <ul id="authorized-macs-list"></ul>
                        <h5 class="accent-blue" style="display: flex; align-items: center; justify-content: space-between;">
                            Restricted Zones
                            <button type="button" class="toggle-button" id="enable-drawing">+</button>
                        </h5>
                        <h5 class="accent-blue">Unauthorized Devices in Restricted Zones</h5>
                        <ul id="unauthorized-devices-list"></ul>
                    </div>
                </div>
            </div>
            <div id="logs-tab" class="col s12 tab-content hidden">
                <label>
                    <input type="checkbox" id="showBluetooth">
                    <span>Show only Bluetooth devices with a name</span>
                </label>
                <table id="log-table" class="highlight">
                    <thead>
                        <tr>
                            <th>IP Address</th>
                            <th>Time</th>
                            <th>Device Name</th>
                            <th>MAC Address</th>
                            <th>Signal Strength</th>
                        </tr>
                    </thead>
                    <tbody>
                        {% for ip, logs in log_data.items() %}
                            {% for log in logs %}
                                <tr class="log-row">
                                    <td>{{ ip }}</td>
                                    <td>{{ log[0] }}</td>
                                    <td class="device-name">{{ log[1] }}</td>
                                    <td>{{ log[2] }}</td>
                                    <td>{{ log[3] }}</td>
                                    <td class="log-data" style="display:none">{{ log[4] }}</td>
                                </tr>
                            {% endfor %}
                        {% endfor %}
                    </tbody>
                </table>
            </div>
            <div id="device-history-tab" class="col s12 tab-content hidden">
                <div class="row">
                    <div class="col s8">
                        <div class="gridmap-container">
                            <div id="history-view" class="gridmap"></div>
                        </div>
                        <div class="legend">
                            <span>1 meter = 100px</span>
                        </div>
                    </div>
                    <div class="col s4 sidebar">
                        <h5 class="accent-blue">Device List</h5>
                        <ul id="device-list" class="device-list"></ul>
                        <h5 class="accent-blue">Location History</h5>
                        <ul id="history-list" class="history-list"></ul>
                    </div>
                </div>
            </div>
            <div id="heatmap-tab" class="col s12 tab-content hidden">
                <div class="row">
                    <div class="col s8">
                        <div class="gridmap-container">
                            <div id="gridmap" class="gridmap"></div>
                        </div>
                        <div class="legend">
                            <span>1 meter = 100px</span>
                        </div>
                    </div>
                    <div class="col s4 sidebar">
                        <h5 class="accent-blue">Heatmap Controls</h5>
                        <button id="generateHeatmapButton" class="btn accent-blue-bg">Generate Heatmap</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>